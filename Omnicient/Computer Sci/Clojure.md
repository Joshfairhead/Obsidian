---
Tags: [Frameworks, Primitives]
---
Related: [[Computer Science]] [[Clojure from the Ground Up]]

# Clojure
- # Intro
    - About a month ago and a half ago I tweeted the chart above. Before that, I wasn‚Äôt sure I wanted to learn Clojure. The response from the Clojure community was pretty compelling, though, and the more I looked into it, the more I was convinced that it would be a good decision, regardless if I stuck with Clojure long-term. Well, I‚Äôm here today to tell you that I‚Äôm extremely pleased with the results of this experiment. I plan to stick with Clojure for the foreseeable future. And quite honestly, I would not be sad if I never had to write another line of JavaScript or [[Python]] again.
    - But I don‚Äôt want to make this about imperative or object-oriented vs functional programming. Tribalism is a big problem in the programming world (and the real world). I think rising above the flame wars and taking the best from each side and dropping the worst is ultimately how one can avoid a local optima. You should play with [[[[Vim]]]], Emacs, and VS Code; you should learn [[OOP]], FP, and [[logic programming]]; you should use DuckDuckGo and Google, Firefox and Chrome; you should use Linux, Apple, NixOS, and Win‚Äì okay I won‚Äôt go that far.
- # What convinced me to learn Clojure
- ## The chart
    - The chart I tweeted is from the [2019 Stack Overflow Survey](https://insights.stackoverflow.com/survey/2019#work-_-salary-and-experience-by-developer-type).
    - The responses to my tweet were fairly balanced between the former and the latter. Ultimately, I don‚Äôt know the answer to the question, but I don‚Äôt think it really matters. The chart is compressing the experiences of 88,883 software developers. At best it can only tell us correlation. But that‚Äôs all you need to know.
    - Experience and money are correlated, duh. But Clojure correlates with experience! I couldn‚Äôt stop thinking about this fact.
    - You see, the biggest change for me in the past year or so has been a shift in my decision-making towards longer-term thinking. I‚Äôm 23, so I‚Äôm young enough that compound interest actually applies to me and old enough to actually care.
    - The truth is, the longer you stick with something, the more you intrinsically love it. And the data was there. Clojurians love it.
    - I think this is generally an under-appreciated fact about software engineering and computer science: all contributions to these two fields are less than 70 years old. We don‚Äôt have great traditions as in philosophy, mathematics, and literature that reach back centuries or millennia, and even within engineering, software is the youngest discipline. But the works we produce will far outlast any physical works (assuming the electronics and energy guys keep the lights on). If your dinky little JS bundle is scraped by Google or the Internet Archive, it‚Äôs going to be remembered forever.
    - I for one would want a language that champions posterity and longevity, which in developer-terms might be backwards-compatibility, reliability, maintainability, and accretion. Clojure and Datomic do just that.
    - Finally, on the money piece, I don‚Äôt think Clojurians care that much about it. I believe Clojurians are more so craftsmen and practitioners who intrinsically love what they do. Besides, we know if you just want ‚Äúa job‚Äù, you should do JS, Java, or .NET. In this case, you‚Äôll have far more jobs to apply to and compete with far more people, solidifying your status as a labor commodity.
- ## [[Paul Graham]]
    - Something that has never left me was Paul Graham‚Äôs [[[Beating the Averages]]](http://www.paulgraham.com/avg.html). I read this post around 4 years ago, when I was first getting into startups and before I even knew how to code. What stuck with me was not that he believed Lisp was the most powerful language, but that programmers could never know what the most powerful language was unless they used it.
    - Lisp is so great not because of some magic quality visible only to devotees, but because it is simply the most powerful language available. And the reason everyone doesn't use it is that programming languages are not merely technologies, but habits of mind as well, and nothing changes slower. Of course, both these answers need explaining."
        - In the same way that I believe all programmers should learn several paradigms and text editors, I believe everyone should learn to code if they have the opportunity. Not for some generic economic reason, but because it changes the way you think and it changes the way you learn. #[[meta-cognition]]
        - I think most programmers would agree with the latter. But then many fail to extend this logic to learning a different paradigm or a sufficiently different language.
        - If you want to change your consciousness, learn Clojure. You heard it here first, folks. Clojure is a mind-altering activity. Almost as good as meditation.
- ## ‚Äú**Every line of code is technical debt.**‚Äù
    - The final thing that convinced me to begin learning Clojure were these two anecdotes of how little code you needed to write.
    - In Gene Kim‚Äôs Love Letter To Clojure, he talks about rewriting an app 3 times:
        - ‚ÄúIn 2012, Flynn and Raechel Little wrote the first version as an iPad app in Objctive-C‚Äîit was about **3,000 lines of code**. (They did such an awesome job!! It worked splendidly until iOS 7 or so, when something broke terribly and it wouldn‚Äôt even start up anymore.)‚Äù
        - ‚ÄúIn 2015, I rewrote it as a **JavaScript/React** application, and it was about **1,500 lines of code**.‚Äù
        - ‚ÄúIn 2017, I rewrote it again as a **ClojureScript** application, and it was only **500 lines of code**! Holy cow!!!‚Äù
    - From the podcast Functional Programming with Jessica Kerr on Software Engineering Daily:
        - When asked about the benefits of Clojure, Jess says:
    - Clojure code is incredibly dense. **If I have a file with 30 lines of code, it might as well be 1000 lines of java.** I‚Äôm not exaggerating. The code does a whole lot in a few words and once you‚Äôre comfortable with Clojure, man you can whip out a web service really fast.
    - Later on, when talking about deployment and software more generally, Jess says:
    - **Every line of code is technical debt.**‚Äù
    - Now obviously you can tell Gene‚Äôs bias from his article title. Jessica, on the other hand, is a functional programming polyglot, and in the podcast talks about her experiences with not only Clojure but also Elixir, Elm, [[Haskell]], and [[Scala]].
    - Regardless, I was astonished that [Gene](https://twitter.com/RealGeneKim) and [Jess](https://twitter.com/jessitron), who both have decades of experience in industry and pretty large followings as technical influencers, cited Clojure as having two orders of magnitude less code than other languages.
    - I mean‚Ä¶ that‚Äôs unbelievable, and if that doesn‚Äôt convince you, I‚Äôm not quite sure what will.
- # Why I‚Äôm staying
    - One measure of how ferociously you are on the learning curve is the velocity of revelations you have. The two periods of my programming career where I had the most back-to-back revelations were when I was learning [[Vim]] and this past month learning Clojure. And if you‚Äôre wondering what I mean by a revelation, I mean an insight, an a-ha moment so profound it stirs something in your soul. Ya I wouldn‚Äôt mind optimizing for revelations.
- ## The [[REPL]]
    - Take 15 minutes and watch this video by Val. You will never want to program without a [[REPL]] again. https://vvvvalvalval.github.io/posts/what-makes-a-good-repl.html
- ## Datomic, Datascript, and Datalog
    - I don‚Äôt even know where to begin. Datomic is so far in the future, so ahead of the curve, it feels like cheating (this is a common feeling I experience writing Clojure). Datomic might actually be Clojure‚Äôs best-kept secret.
    - This section deserves its own article, and I will link it here when I learn more, but the TL;DR is:
        - Datalog is a [[logic programming]] query language that uses set logic.
        - Datascript is a frontend port of Datomic, which functions as a frontend store that handles application state (think redux). One way to query the store is with Datalog.
    - Datomic is a durable storage service that can be self-hosted or hosted on AWS.
        - It is distributed yet fully ACID-compliant, because it unbundles the database. It decouples reading, writing, and caching into separate processes.
        - It is immutable and accumulate-only, like git or a blockchain. This notion of time provides the following:
            - You can query the database at different points in time.
            - You can query the db since a time.
            - You can query the db as-of time.
            - You can query the db with a transaction, letting you diff the databse: what is the before and after if I do this transaction.
            - You can query for the schema at different point in history.
        - Datomic‚Äôs version of a ‚Äúrecord‚Äù is a Datom, a 5-tuple with the fields:
            - entity
            - attribute
            - value
            - transaction
            - operation type
        - Datoms as the building block provide flexibility:
            - You don‚Äôt need to pre-define the schema to add attributes.
            - You can update the schema through transactions (no more migrations!!!).
            - ‚ÄúYou can query for the schema at different point in history.‚Äù
            - You can join any datom(s) with any datom(s). You don‚Äôt need to define single-to-many or many-to-many relationships.
            - You can trivially make recursive queries.
            - You can trivially make reverse lookups (graph db use-case).
        - Datomic is indexed 4 different ways such that you can model the other major access styles
            - row indexing (e.g.¬†SQL)
            - key/value indexing (e.g.¬†redis)
            - column indexing (e.g.¬†Cassandra)
            - graph (e.g.¬†Neo4j)
            - document indexing (e.g.¬†MongoDB)
            - From Day of Datomic Cloud 2018:
                - ![](assets/clojurething.png)

- ## Spec
    - A common complaint of Clojure is being dynamically typed and the downsides associated with that. I haven‚Äôt used it yet, but Clojure spec addresses this and more. I am so so so excited to use Spec in my daily life. I never want to have to write a test again.
    - [üîó](https://www.youtube.com/watch?v=VNTQ-M_uSo8)https://www.youtube.com/watch?v=VNTQ-M_uSo8
- ## Macros
    - From [[Clojure from the Ground Up]], an amazing intro to Clojure:
    - Clojure isn‚Äôt just¬†function-oriented¬†in its syntax; it can be object-oriented, and stack-oriented, and array-oriented, and so on‚Äìand¬†**mix all of these styles freely, in a controlled way**. If you don‚Äôt like the way the language fits a certain problem, **you can write a macro which defines a¬†new¬†language, specifically for that subproblem**
    - [[Paul Graham]] on using macros at Viaweb:
    - But I think I can give a kind of argument that might be convincing. The source code of the Viaweb editor was probably about 20-25% macros. Macros are harder to write than ordinary Lisp functions, and it's considered to be bad style to use them when they're not necessary. So every macro in that code is there because it has to be. What that means is that at least 20-25% of the code in this program is doing things that you can't easily do in any other language. However skeptical the Blub programmer might be about my claims for the mysterious powers of Lisp, this ought to make him curious. We weren't writing this code for our own amusement. We were a tiny startup, programming as hard as we could in order to put technical barriers between us and our competitors
- ## [[Good Artists Copy; Great Artists Steal]]
    - [Better destructuring than Javascript](https://clojure.org/guides/destructuring#_associative_destructuring)
    - [Better list comprehension than Python](https://clojuredocs.org/clojure.core/for)
    - [Better go routines than Go](https://blog.drewolson.org/clojure-go-comparison)
	I don‚Äôt actually know if Clojure‚Äôs concurrency library, core.async, is better than go‚Äôs go routines. I haven‚Äôt used either in a running application, but they seem comparable based off a Google search. What I can say is that Clojure implemented Go‚Äôs defining feature and namesake as a library. That‚Äôs the power of [[macros]], baby.
- # Things I don‚Äôt like
    - There are too many libraries! So many routers and [HTTP servers](https://purelyfunctional.tv/mini-guide/clojure-web-servers/). Just start with Ring and Compojure. #[[Clojure Routers - [PurelyFunctional.tv](http://PurelyFunctional.tv)]]
    - There are so many resources and books, aimed at various levels. See ‚ÄúBeginner Resources‚Äù for how I‚Äôve been learning the fundamentals.
    - There are a lot of IDEs too. ‚ÄúClojure for the Brave and True‚Äù gives a nice starter kit for Emacs, but going beyond that requires tinkering with Emacs. My guess is that VS Code's Calva is quite usable. I've been liking Intelli-J's Cursive. And if you use [[Vim]] you'll probably be fine :)
    - Error messages can also be too much and sometimes not super informative, Clojure being dynamically typed and outputting Clojure and Java stack traces. I think ‚ÄúSpec‚Äù will help with this, ‚ÄúClojure from the Ground Up‚Äù has a fantastic section on debugging, and ‚ÄúThe [[REPL]]‚Äù is your friend.
- # Beginner Resources
- ### Clojure from the Ground Up
    - Not exhaustive but the most succinct and conceptually concise intro I‚Äôve found so far.
    - Can do in a few days.
- ### Clojure for the Brave and True
    - A much broader intro than Ground Up. Very playful and approachable.
    - Can do over the course of a few weeks.
    - I learned enough to where I could I build stuff and then skipped around and returned to skipped chapters as needed.
- ### http://www.4clojure.com/
    - Test-driven / koan-driven learning.
    - I‚Äôve done about half of the 156 questions. Seems like second half turns into leetcode advanced problems, i.e.¬†somewhat contrived.
